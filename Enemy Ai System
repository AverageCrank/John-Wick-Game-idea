// ==================================================
// JOHN WICK ENEMY AI SYSTEM
// Smart AI that responds to player combos and creates tactical challenges
// ==================================================

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Components/PawnSensingComponent.h"
#include "AIController.h"
#include "BehaviorTree/BehaviorTreeComponent.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "Perception/AIPerceptionComponent.h"
#include "Engine/Engine.h"
#include "JohnWickEnemy.generated.h"

// Forward declarations
class AJohnWickPlayer;
class UBehaviorTreeComponent;
class UBlackboardComponent;

// Enemy types and states
UENUM(BlueprintType)
enum class EEnemyType : uint8
{
    Thug        UMETA(DisplayName = "Street Thug"),
    Enforcer    UMETA(DisplayName = "Enforcer"),
    Assassin    UMETA(DisplayName = "Professional Assassin"),
    Elite       UMETA(DisplayName = "Elite Hunter"),
    Boss        UMETA(DisplayName = "Boss")
};

UENUM(BlueprintType)
enum class EEnemyState : uint8
{
    Patrol      UMETA(DisplayName = "Patrolling"),
    Alert       UMETA(DisplayName = "Alert"),
    Hunting     UMETA(DisplayName = "Hunting Player"),
    Combat      UMETA(DisplayName = "In Combat"),
    Flanking    UMETA(DisplayName = "Flanking"),
    Suppressing UMETA(DisplayName = "Suppressing Fire"),
    Retreating  UMETA(DisplayName = "Retreating"),
    Dead        UMETA(DisplayName = "Dead")
};

UENUM(BlueprintType)
enum class ECombatRole : uint8
{
    Aggressive  UMETA(DisplayName = "Aggressive Rusher"),
    Defensive   UMETA(DisplayName = "Defensive Cover"),
    Support     UMETA(DisplayName = "Support/Flanker"),
    Sniper      UMETA(DisplayName = "Long Range")
};

// Enemy stats structure
USTRUCT(BlueprintType)
struct FEnemyStats
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float Health = 100.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float MaxHealth = 100.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float Damage = 20.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float AccuracyBase = 0.7f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float ReactionTime = 0.5f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float MovementSpeed = 300.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float SightRange = 2000.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float HearingRange = 1500.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    bool bCanDisarmPlayer = false;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    bool bUsesAdvancedTactics = false;

    FEnemyStats()
    {
        Health = 100.0f;
        MaxHealth = 100.0f;
        Damage = 20.0f;
        AccuracyBase = 0.7f;
        ReactionTime = 0.5f;
        MovementSpeed = 300.0f;
        SightRange = 2000.0f;
        HearingRange = 1500.0f;
        bCanDisarmPlayer = false;
        bUsesAdvancedTactics = false;
    }
};

// ==================================================
// MAIN ENEMY CHARACTER CLASS
// ==================================================

UCLASS()
class JOHNWICK_API AJohnWickEnemy : public ACharacter
{
    GENERATED_BODY()

public:
    AJohnWickEnemy();

protected:
    virtual void BeginPlay() override;

public:
    virtual void Tick(float DeltaTime) override;

    // ===== CORE PROPERTIES =====
    
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Enemy Setup")
    EEnemyType EnemyType;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Enemy State")
    EEnemyState CurrentState;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Enemy Setup")
    ECombatRole CombatRole;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Enemy Setup")
    FEnemyStats Stats;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Combat")
    AJohnWickPlayer* TargetPlayer;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weapons")
    EWeaponType CurrentWeapon;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Combat")
    int32 CurrentAmmo;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Combat")
    float LastShotTime;

    // ===== TACTICAL AI PROPERTIES =====
    
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Tactics")
    FVector LastKnownPlayerLocation;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Tactics")
    float CombatTimer;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Tactics")
    bool bIsInCover;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Tactics")
    bool bIsSuppressing;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Tactics")
    FVector FlankingTarget;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Tactics")
    TArray<AJohnWickEnemy*> AlliedEnemies;

    // Response to player combos
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI Response")
    int32 PlayerComboLevel;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AI Response")
    float FearLevel;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AI Response")
    bool bPlayerInBulletTime;

    // ===== CORE AI FUNCTIONS =====
    
    UFUNCTION(BlueprintCallable, Category = "AI")
    void UpdateAIState();

    UFUNCTION(BlueprintCallable, Category = "AI")
    void DetectPlayer();

    UFUNCTION(BlueprintCallable, Category = "AI")
    void RespondToPlayerCombo(int32 ComboLevel);

    UFUNCTION(BlueprintCallable, Category = "AI")
    void CoordinateWithAllies();

    // ===== COMBAT FUNCTIONS =====
    
    UFUNCTION(BlueprintCallable, Category = "Combat")
    void EnterCombat();

    UFUNCTION(BlueprintCallable, Category = "Combat")
    void FireAtPlayer();

    UFUNCTION(BlueprintCallable, Category = "Combat")
    bool CanSeePlayer() const;

    UFUNCTION(BlueprintCallable, Category = "Combat")
    void TakeCover();

    UFUNCTION(BlueprintCallable, Category = "Combat")
    void StartFlanking();

    UFUNCTION(BlueprintCallable, Category = "Combat")
    void SuppressiveFire();

    // ===== TACTICAL RESPONSES =====
    
    UFUNCTION(BlueprintCallable, Category = "Tactics")
    void ReactToPlayerBulletTime();

    UFUNCTION(BlueprintCallable, Category = "Tactics")
    void AttemptDisarm();

    UFUNCTION(BlueprintCallable, Category = "Tactics")
    void CallForBackup();

    UFUNCTION(BlueprintCallable, Category = "Tactics")
    void AdaptToPlayerStyle();

    // ===== DAMAGE AND DEATH =====
    
    UFUNCTION(BlueprintCallable, Category = "Combat")
    virtual float TakeDamage(float DamageAmount, struct FDamageEvent const& DamageEvent, 
                           class AController* EventInstigator, AActor* DamageCauser) override;

    UFUNCTION(BlueprintCallable, Category = "Combat")
    void Die();

    UFUNCTION(BlueprintCallable, Category = "Combat")
    void DropWeapon();

private:
    // Internal AI logic
    void PatrolBehavior();
    void HuntingBehavior();
    void CombatBehavior();
    void FlankingBehavior();
    void RetreatBehavior();

    // Utility functions
    FVector FindCoverLocation();
    FVector FindFlankingRoute();
    float CalculateAccuracy();
    void UpdateAlliedCommunication();
    bool ShouldRetreat() const;

    // Timers and counters
    float StateTimer;
    float NextDecisionTime;
    float LastPlayerSighting;
    int32 ShotsWithoutHit;
};

// ==================================================
// AI CONTROLLER CLASS
// ==================================================

UCLASS()
class JOHNWICK_API AJohnWickEnemyController : public AAIController
{
    GENERATED_BODY()

public:
    AJohnWickEnemyController();

protected:
    virtual void BeginPlay() override;

public:
    // AI Components
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI")
    class UBehaviorTreeComponent* BehaviorComp;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI")
    class UBlackboardComponent* BlackboardComp;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "AI")
    class UBehaviorTree* BehaviorTree;

    // AI Decision Making
    UFUNCTION(BlueprintCallable, Category = "AI")
    void SetPlayerTarget(AJohnWickPlayer* Player);

    UFUNCTION(BlueprintCallable, Category = "AI")
    void UpdateBlackboardValues();

    UFUNCTION(BlueprintCallable, Category = "AI")
    void MakeGlobalDecision();

private:
    AJohnWickEnemy* ControlledEnemy;
};

// ==================================================
// IMPLEMENTATION
// ==================================================

AJohnWickEnemy::AJohnWickEnemy()
{
    PrimaryActorTick.bCanEverTick = true;

    // Set default values
    EnemyType = EEnemyType::Thug;
    CurrentState = EEnemyState::Patrol;
    CombatRole = ECombatRole::Aggressive;
    CurrentWeapon = EWeaponType::Pistol;
    
    bIsInCover = false;
    bIsSuppressing = false;
    CombatTimer = 0.0f;
    FearLevel = 0.0f;
    PlayerComboLevel = 0;
    
    StateTimer = 0.0f;
    NextDecisionTime = 0.0f;
    LastPlayerSighting = 0.0f;
    ShotsWithoutHit = 0;

    // Configure stats based on enemy type (will be overridden in BeginPlay)
    Stats = FEnemyStats();
}

void AJohnWickEnemy::BeginPlay()
{
    Super::BeginPlay();
    
    // Configure stats based on enemy type
    switch (EnemyType)
    {
        case EEnemyType::Thug:
            Stats.Health = 75.0f;
            Stats.Damage = 15.0f;
            Stats.AccuracyBase = 0.5f;
            Stats.ReactionTime = 0.8f;
            Stats.bUsesAdvancedTactics = false;
            break;
            
        case EEnemyType::Enforcer:
            Stats.Health = 120.0f;
            Stats.Damage = 25.0f;
            Stats.AccuracyBase = 0.7f;
            Stats.ReactionTime = 0.6f;
            Stats.bUsesAdvancedTactics = true;
            break;
            
        case EEnemyType::Assassin:
            Stats.Health = 100.0f;
            Stats.Damage = 35.0f;
            Stats.AccuracyBase = 0.85f;
            Stats.ReactionTime = 0.3f;
            Stats.bUsesAdvancedTactics = true;
            Stats.bCanDisarmPlayer = true;
            break;
            
        case EEnemyType::Elite:
            Stats.Health = 150.0f;
            Stats.Damage = 40.0f;
            Stats.AccuracyBase = 0.9f;
            Stats.ReactionTime = 0.2f;
            Stats.bUsesAdvancedTactics = true;
            Stats.bCanDisarmPlayer = true;
            break;
            
        case EEnemyType::Boss:
            Stats.Health = 300.0f;
            Stats.Damage = 50.0f;
            Stats.AccuracyBase = 0.95f;
            Stats.ReactionTime = 0.1f;
            Stats.bUsesAdvancedTactics = true;
            Stats.bCanDisarmPlayer = true;
            break;
    }
    
    Stats.MaxHealth = Stats.Health;
    CurrentAmmo = 30; // Full magazine to start
}

void AJohnWickEnemy::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    
    StateTimer += DeltaTime;
    CombatTimer += DeltaTime;
    
    // Update AI state machine
    UpdateAIState();
    
    // Detect player
    DetectPlayer();
    
    // Handle current behavior
    switch (CurrentState)
    {
        case EEnemyState::Patrol:
            PatrolBehavior();
            break;
        case EEnemyState::Hunting:
            HuntingBehavior();
            break;
        case EEnemyState::Combat:
            CombatBehavior();
            break;
        case EEnemyState::Flanking:
            FlankingBehavior();
            break;
        case EEnemyState::Retreating:
            RetreatBehavior();
            break;
    }
}

// ===== CORE AI FUNCTIONS =====

void AJohnWickEnemy::UpdateAIState()
{
    EEnemyState PreviousState = CurrentState;
    
    // State transition logic
    switch (CurrentState)
    {
        case EEnemyState::Patrol:
            if (TargetPlayer && CanSeePlayer())
            {
                CurrentState = EEnemyState::Alert;
                StateTimer = 0.0f;
            }
            break;
            
        case EEnemyState::Alert:
            if (StateTimer > Stats.ReactionTime)
            {
                CurrentState = EEnemyState::Combat;
                EnterCombat();
            }
            break;
            
        case EEnemyState::Combat:
            // Dynamic state changes based on combat situation
            if (ShouldRetreat())
            {
                CurrentState = EEnemyState::Retreating;
            }
            else if (Stats.bUsesAdvancedTactics && CombatTimer > 5.0f && FMath::RandRange(0.0f, 1.0f) > 0.7f)
            {
                CurrentState = EEnemyState::Flanking;
                StartFlanking();
            }
            break;
            
        case EEnemyState::Flanking:
            if (FVector::Dist(GetActorLocation(), FlankingTarget) < 150.0f || StateTimer > 8.0f)
            {
                CurrentState = EEnemyState::Combat;
            }
            break;
            
        case EEnemyState::Retreating:
            if (Stats.Health > Stats.MaxHealth * 0.5f)
            {
                CurrentState = EEnemyState::Combat;
            }
            break;
    }
    
    // State change logging
    if (CurrentState != PreviousState)
    {
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s changed state from %d to %d"), 
               *GetName(), (int32)PreviousState, (int32)CurrentState);
        StateTimer = 0.0f;
    }
}

void AJohnWickEnemy::DetectPlayer()
{
    if (!TargetPlayer)
    {
        // Find player in world
        TargetPlayer = Cast<AJohnWickPlayer>(GetWorld()->GetFirstPlayerController()->GetPawn());
    }
    
    if (TargetPlayer && CanSeePlayer())
    {
        LastKnownPlayerLocation = TargetPlayer->GetActorLocation();
        LastPlayerSighting = GetWorld()->GetTimeSeconds();
        
        // Get player's current combo level for AI response
        PlayerComboLevel = TargetPlayer->ComboLevel;
        bPlayerInBulletTime = TargetPlayer->bIsBulletTimeActive;
        
        RespondToPlayerCombo(PlayerComboLevel);
    }
}

void AJohnWickEnemy::RespondToPlayerCombo(int32 ComboLevel)
{
    if (ComboLevel != PlayerComboLevel)
    {
        PlayerComboLevel = ComboLevel;
        
        // AI becomes more aggressive/careful based on player combo
        switch (ComboLevel)
        {
            case 0:
                // Player not in combo - normal behavior
                FearLevel = FMath::Max(0.0f, FearLevel - 0.1f);
                break;
                
            case 1:
                // Low combo - slightly more cautious
                FearLevel += 0.1f;
                break;
                
            case 2:
            case 3:
                // Medium combo - increase aggression and coordination
                FearLevel += 0.2f;
                if (Stats.bUsesAdvancedTactics)
                {
                    CoordinateWithAllies();
                }
                break;
                
            case 4:
            case 5:
                // High combo - desperate measures
                FearLevel += 0.4f;
                if (Stats.bCanDisarmPlayer && FMath::RandRange(0.0f, 1.0f) > 0.6f)
                {
                    AttemptDisarm();
                }
                CallForBackup();
                break;
        }
        
        FearLevel = FMath::Clamp(FearLevel, 0.0f, 1.0f);
        
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s responding to player combo level %d (Fear: %.2f)"), 
               *GetName(), ComboLevel, FearLevel);
    }
}

// ===== BEHAVIOR IMPLEMENTATIONS =====

void AJohnWickEnemy::PatrolBehavior()
{
    // Simple patrol - move to random nearby points
    if (StateTimer > 5.0f) // Change direction every 5 seconds
    {
        FVector RandomDirection = FMath::VRand() * 1000.0f;
        RandomDirection.Z = 0; // Keep on ground
        
        FVector TargetLocation = GetActorLocation() + RandomDirection;
        // Move toward target (simplified - you'd use AI movement in real implementation)
        
        StateTimer = 0.0f;
    }
}

void AJohnWickEnemy::HuntingBehavior()
{
    if (TargetPlayer)
    {
        // Move toward last known player location
        FVector Direction = (LastKnownPlayerLocation - GetActorLocation()).GetSafeNormal();
        AddMovementInput(Direction, 0.8f);
        
        // If we reach the location and don't see player, start searching
        float DistanceToTarget = FVector::Dist(GetActorLocation(), LastKnownPlayerLocation);
        if (DistanceToTarget < 200.0f && !CanSeePlayer())
        {
            // Search pattern would go here
            CurrentState = EEnemyState::Patrol;
        }
    }
}

void AJohnWickEnemy::CombatBehavior()
{
    if (!TargetPlayer) return;
    
    // Decide on combat action based on role and situation
    switch (CombatRole)
    {
        case ECombatRole::Aggressive:
            // Rush the player while firing
            if (!bIsInCover)
            {
                FVector Direction = (TargetPlayer->GetActorLocation() - GetActorLocation()).GetSafeNormal();
                AddMovementInput(Direction, 0.6f);
            }
            FireAtPlayer();
            break;
            
        case ECombatRole::Defensive:
            // Take cover and provide suppressive fire
            if (!bIsInCover)
            {
                TakeCover();
            }
            else
            {
                SuppressiveFire();
            }
            break;
            
        case ECombatRole::Support:
            // Try to flank or support allies
            if (AlliedEnemies.Num() > 0)
            {
                CoordinateWithAllies();
            }
            else
            {
                StartFlanking();
            }
            break;
            
        case ECombatRole::Sniper:
            // Keep distance and accurate fire
            if (FVector::Dist(GetActorLocation(), TargetPlayer->GetActorLocation()) < 1000.0f)
            {
                // Move to better position
                FVector AwayDirection = (GetActorLocation() - TargetPlayer->GetActorLocation()).GetSafeNormal();
                AddMovementInput(AwayDirection, 0.4f);
            }
            else
            {
                FireAtPlayer();
            }
            break;
    }
    
    // React to player bullet time
    if (bPlayerInBulletTime)
    {
        ReactToPlayerBulletTime();
    }
}

void AJohnWickEnemy::FlankingBehavior()
{
    // Move to flanking position
    FVector Direction = (FlankingTarget - GetActorLocation()).GetSafeNormal();
    AddMovementInput(Direction, 1.0f);
    
    // Fire opportunistically while flanking
    if (CanSeePlayer() && FMath::RandRange(0.0f, 1.0f) > 0.7f)
    {
        FireAtPlayer();
    }
}

void AJohnWickEnemy::RetreatBehavior()
{
    if (TargetPlayer)
    {
        // Move away from player
        FVector AwayDirection = (GetActorLocation() - TargetPlayer->GetActorLocation()).GetSafeNormal();
        AddMovementInput(AwayDirection, 1.0f);
        
        // Try to find cover while retreating
        if (!bIsInCover)
        {
            TakeCover();
        }
    }
}

// ===== COMBAT FUNCTIONS =====

void AJohnWickEnemy::EnterCombat()
{
    UE_LOG(LogTemp, Warning, TEXT("Enemy %s entering combat!"), *GetName());
    
    // Alert nearby allies
    CoordinateWithAllies();
    
    // Set initial combat posture based on role
    switch (CombatRole)
    {
        case ECombatRole::Defensive:
            TakeCover();
            break;
        case ECombatRole::Support:
            StartFlanking();
            break;
    }
}

void AJohnWickEnemy::FireAtPlayer()
{
    if (!TargetPlayer || CurrentAmmo <= 0) return;
    
    float CurrentTime = GetWorld()->GetTimeSeconds();
    if (CurrentTime - LastShotTime < 0.2f) return; // Fire rate limit
    
    // Calculate accuracy based on multiple factors
    float Accuracy = CalculateAccuracy();
    
    // Line trace to player with accuracy deviation
    FVector StartLocation = GetActorLocation();
    FVector TargetDirection = (TargetPlayer->GetActorLocation() - StartLocation).GetSafeNormal();
    
    // Add accuracy deviation
    float DeviationAngle = (1.0f - Accuracy) * 30.0f; // Up to 30 degrees deviation
    FVector RandomDeviation = FMath::VRandCone(TargetDirection, FMath::DegreesToRadians(DeviationAngle));
    
    FVector EndLocation = StartLocation + (RandomDeviation * 3000.0f);
    
    // Perform line trace
    FHitResult HitResult;
    FCollisionQueryParams QueryParams;
    QueryParams.AddIgnoredActor(this);
    
    bool bHit = GetWorld()->LineTraceSingleByChannel(
        HitResult,
        StartLocation,
        EndLocation,
        ECollisionChannel::ECC_Pawn,
        QueryParams
    );
    
    if (bHit && HitResult.GetActor() == TargetPlayer)
    {
        // Hit player!
        TargetPlayer->TakeDamage(Stats.Damage, FDamageEvent(), nullptr, this);
        ShotsWithoutHit = 0;
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s hit player for %.1f damage!"), *GetName(), Stats.Damage);
    }
    else
    {
        ShotsWithoutHit++;
    }
    
    CurrentAmmo--;
    LastShotTime = CurrentTime;
    
    // Reload if out of ammo
    if (CurrentAmmo <= 0)
    {
        // Simple reload - in reality you'd have reload animations
        CurrentAmmo = 30;
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s reloading"), *GetName());
    }
}

bool AJohnWickEnemy::CanSeePlayer() const
{
    if (!TargetPlayer) return false;
    
    FVector StartLocation = GetActorLocation();
    FVector EndLocation = TargetPlayer->GetActorLocation();
    
    // Check if within sight range
    float Distance = FVector::Dist(StartLocation, EndLocation);
    if (Distance > Stats.SightRange) return false;
    
    // Line trace for line of sight
    FHitResult HitResult;
    FCollisionQueryParams QueryParams;
    QueryParams.AddIgnoredActor(this);
    QueryParams.AddIgnoredActor(TargetPlayer);
    
    bool bHit = GetWorld()->LineTraceSingleByChannel(
        HitResult,
        StartLocation,
        EndLocation,
        ECollisionChannel::ECC_WorldStatic,
        QueryParams
    );
    
    return !bHit; // Can see if no obstacles
}

void AJohnWickEnemy::TakeCover()
{
    FVector CoverLocation = FindCoverLocation();
    if (CoverLocation != FVector::ZeroVector)
    {
        // Move to cover (simplified)
        bIsInCover = true;
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s taking cover"), *GetName());
    }
}

void AJohnWickEnemy::StartFlanking()
{
    FlankingTarget = FindFlankingRoute();
    if (FlankingTarget != FVector::ZeroVector)
    {
        CurrentState = EEnemyState::Flanking;
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s starting flanking maneuver"), *GetName());
    }
}

// ===== TACTICAL RESPONSES =====

void AJohnWickEnemy::ReactToPlayerBulletTime()
{
    // AI tries to get out of line of fire when player activates bullet time
    if (CanSeePlayer())
    {
        // Emergency evasion
        FVector EvasionDirection = FMath::VRand();
        EvasionDirection.Z = 0;
        AddMovementInput(EvasionDirection, 1.5f); // Move faster during bullet time
        
        // Take cover immediately if possible
        if (!bIsInCover)
        {
            TakeCover();
        }
        
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s evading bullet time!"), *GetName());
    }
}

void AJohnWickEnemy::AttemptDisarm()
{
    if (!Stats.bCanDisarmPlayer || !TargetPlayer) return;
    
    float DistanceToPlayer = FVector::Dist(GetActorLocation(), TargetPlayer->GetActorLocation());
    if (DistanceToPlayer < 300.0f) // Close range required
    {
        // Rush player for disarm attempt
        FVector Direction = (TargetPlayer->GetActorLocation() - GetActorLocation()).GetSafeNormal();
        AddMovementInput(Direction, 2.0f); // Sprint to player
        
        UE_LOG(LogTemp, Warning, TEXT("Enemy %s attempting to disarm player!"), *GetName());
        
        // This would trigger a disarm mini-game or QTE in a full implementation
    }
}

void AJohnWickEnemy::CoordinateWithAllies()
{
    // Find nearby allies
    TArray<AActor*> FoundActors;
    UWorld* World = GetWorld();
    if (World)
    {
        for (TActorIterator<AJohnWickEnemy> ActorIterator(World); ActorIterator; ++ActorIterator)
        {
            AJohnWickEnemy* OtherEnemy = *ActorIterator;
            if (OtherEnemy != this && !OtherEnemy->IsPendingKill())
            {
                float Distance = FVector::Dist(GetActorLocation(), OtherEnemy->GetActorLocation());
                if (Distance < 2000.0f) // Communication range
                {
                    AlliedEnemies.AddUnique(OtherEnemy);
                    OtherEnemy->AlliedEnemies.AddUnique(this);
                }
            }
        }
    }
    
    // Simple coordination: if allies are flanking, provide suppressive fire
    if (AlliedEnemies.Num() > 0)
    {
        bool bAlliesAreFlanking = false;
        for (AJohnWickEnemy* Ally : AlliedEnemies)
        {
            if (Ally && Ally->CurrentState == EEnemyState::Flanking)
            {
                bAlliesAreFlanking = true;
                break;
            }
        }
        
        if (bAlliesAreFlanking && CombatRole != ECombatRole::Support)
        {
            SuppressiveFire();
        }
    }
}

// ===== UTILITY FUNCTIONS =====

FVector AJohnW
